"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mysql_1 = require("mysql");
class MySQLProvider {
    constructor(config) {
        this.initialized = false;
        this.host = config.host;
        this.username = config.username;
        this.password = config.password;
        this.database = config.database;
        this.table = config.table;
    }
    async init() {
        this.db = mysql_1.createConnection({
            host: this.host,
            user: this.username,
            password: this.password,
            database: this.database
        });
        this.db.connect();
        this.db.query(`CREATE TABLE IF NOT EXISTS ${this.table} (vKey VARCHAR(255) PRIMARY KEY, vValue TEXT)`, (error, result, fields) => {
            if (error)
                throw new Error(`[ VultrexDB / MySQL ]: ${error}`);
        });
        this.initialized = true;
    }
    async set(key, value) {
        this.db.query(`INSERT INTO ${this.table} (vKey, vValue) VALUES ('${key}', '${JSON.stringify(value)}') ON DUPLICATE KEY UPDATE vValue = '${JSON.stringify(value)}'`, (error, result, fields) => {
            if (error)
                throw new Error(`[ VultrexDB / MySQL ]: ${error}`);
        });
    }
    async get(key, defaultValue) {
        const data = await this.db.query(`SELECT * FROM ${this.table} WHERE vKey = '${key}';`, (error, result, fields) => {
            if (error)
                throw new Error(`[ VultrexDB / MySQL ]: ${error}`);
            // console.log(result.length ? JSON.parse(result[0]["value"]) : defaultValue);
            // return result.length ? JSON.parse(result[0]["value"]) : defaultValue;
        });
        console.log(data);
    }
    async getAll(key) {
        const query = key ? `SELECT * FROM ${this.table} WHERE vKey LIKE '%${key}%'` : `SELECT * FROM ${this.table}`;
        await this.db.query(query, (error, result, fields) => {
            if (error)
                throw new Error(`[ VultrexDB / MySQL ]: ${error}`);
            return result.map((data) => ({ key: data["key"], value: JSON.parse(data["value"]) }));
        });
    }
    async size() {
        await this.db.query(`SELECT count(*) FROM ${this.table}`, (error, result, fields) => {
            if (error)
                throw new Error(`[ VultrexDB / MySQL ]: ${error}`);
            return result["count(*)"];
        });
    }
    async delete(key) {
        await this.db.query(`DELETE FROM ${this.table} WHERE key = '${key}'`, (error, result, fields) => {
            if (error)
                throw new Error(`[ VultrexDB / MySQL ]: ${error}`);
        });
    }
    async clear() {
        this.db.query(`DELETE FROM ${this.table}`, (error, result, fields) => {
            if (error)
                throw new Error(`[ VultrexDB / MySQL ]: ${error}`);
        });
    }
}
exports.default = MySQLProvider;
